% This work is licensed under the Creative Commons Attribution-NonCommercial
% 4.0 International License. To view a copy of this license, visit
% http://creativecommons.org/licenses/by-nc/4.0/ or send a letter to Creative
% Commons, PO Box 1866, Mountain View, CA 94042, USA.

\input{../minpream}

\usepackage{fancyvrb}
\usepackage{fvextra}

% Правильное начертание красивых символов
\usepackage[scr=rsfs]{mathalpha}

% Языки
\newcommand{\Lang}{\mathscr{L}}
\newcommand{\Lother}{\mathscr{M}} % другой
\newcommand{\Lexpr}{\mathscr{E}}  % выражений
\newcommand{\Lstat}{\mathscr{S}}  % операторов
\newcommand{\Linst}{\mathscr{I}}  % инструкций
\newcommand{\Lprog}{\mathscr{P}}  % программ

% Другие красивые обозначения
\newcommand{\Conf}{\mathscr{C}} % конфигурация
\newcommand{\Word}{\mathscr{W}} % мир
\newcommand{\Var}{\mathscr{X}}  % переменная

% Семантическое правило
\newcommand{\neatarrow}{\DOTSB\Rightarrow}

% Семантика
\newcommand{\semant}[1]{\llbracket #1 \rrbracket} 

\begin{document}

\section{Первая домашка}

\textbf{Язык программирования} (ЯП) --- множество программ на этом языке. ЯП
--- частный случай всех языков. Любой язык состоит из синтаксиста (правила
построения предложений), сементики (смысл предложений) и прагматики
(взаимодействие с носителем).

В языках программирования разделяют \textbf{абстактный и конкретный синтаксис}.

\textbf{Абстрактный синтаксис языка выражений}:

\fig[0.6]{lexpr-synt}

Задано множество переменных, множество бинарных операций и множество
\textbf{абстрактных синтаксических деревьев} (АСД).

АСД является:

\begin{itemize}
    \item изолированным узлом, который представляет переменную или число;

    \item узлом бинарной операции с двумя дочерними деревьями.
\end{itemize}

Следовательно, дерево определяется по индукции. Дерево упорядочено.

\fig[0.3]{lexpr-ast}

Множество АСД является языком, а каждая программа определяется АСД. Пример АСД:

\fig[0.25]{lexpr-ast-examp1}

Пример конкретного синтаксиса: \texttt{(a + b) * c}. Чтобы абстрактный
синтаксис выразить в конкретный потребуются дополнительные понятния (в данном
случае старшинство операций).

\textbf{Семантика} --- это всюду определенное отображение языка в семантический
домен:
\[
    \semant{\bullet}_\Lang : \Lang \mapsto \mathscr{D}
\]

Функциональный семантический домен --- множество функций.

Введем \textbf{функцию состояния} $\sigma : \Var \to \mathbb{Z}$,
которая связывает переменные с их значениями.

Рассмотрим \textbf{операционную семантику большого шага}. Она определяется тернарным
отношением:
\[
    \neatarrow_\Lexpr\; \subseteq \Sigma \times \Lexpr \times \mathbb{Z}.
\]

Запись $\sigma \overset{e}{\neatarrow}_\Lexpr n$ означает, что вычисление
выражения $e$ в состоянии $\sigma$ дает значение $n$.

Три семантических правила:

\fig[0.5]{big-step-rules}

В случае с переменной мы должны извлечь из переменной число, чтобы получить
результат.

Линия отделят \textbf{посылку} (правило свеху) от \textbf{заключения} (правило снизу). К заключению можно
приступать только если выполнена посылка. Если у правила отсутствует посылка,
то оно является \textbf{аксиомой}. 

\textbf{Базовые операции}:

\fig[0.25]{lama-ops}

Пример программы: $1 \land (1 / 0)$. Пример описания:

\fig[0.4]{big-step-example1}

Результатом будет неопределенность, так как результат деления на ноль не
определен.

Мы рассмотрели \textbf{строгую (strict) семантику}. Функция называется
неопределенной, если функция от неопределенности есть неопределенность.

Добавим уточнение, что бинарная операция $ \neq \land \mid \lor$ и
добавим два новых правила, которые сделают семантику нестрогой по второму аргументу:

\fig[0.7]{non-strict-rule}

Если левый аргумент --- единица, то результат будет единицей. Если левый
аргумент не равен единице, а правй аргемент --- целое число, то результат
вычисляется из этих двух чисел.

\textbf{Обобщение правил} $\neatarrow_\Lexpr$ в семантику
$\semant{\bullet}_\Lexpr$:

\fig[0.15]{main-expr-semant}

Язык состоит из множества синтаксических категорий.
Существует несколько синтаксических категорий. Категорию выражений (expression) мы
рассмотрели. Следующая категория --- операторов (statement). Рассмотрим язык
операторов:

\fig[0.25]{statements}

Второе правило определяет операцию присвоения, где слева находится переменная,
справа --- выражение (рассмотрено ранее).

\fig[0.2]{assign-synt}

Последнее правило определяет композицию операторов.

Определим семантику этого языка. Пусть наш язык описывает программы, которые
принимают строки целых чисел и возвращают строки целых чисел:
\[
    \semant{\bullet} : \Lstat \mapsto \mathbb{Z}^\star \to
    \mathbb{Z}^\star
\]

Семантика большого шага связывает две конфигурации и программу:
\[
    \neatarrow_\Lstat\; \subseteq \mathscr{C} \times \Lstat \times
    \mathscr{C}.
\]

Значит, что при запуске программы в одной конфигурации, через несколько
шагов получаем другую конфигурацию. Семантика большого шага так называется, так
как при переходе выполняется цепочка шагов.

\textbf{Конфигурация} --- это пара состояния и мира:
\[
    \mathscr{C} : \Sigma \times \mathscr{W}
\]

\textbf{Мир} --- это инкапсуляция входного и выходного потока:
\[
    \mathscr{W} : \mathbb{Z}^\star \times \mathbb{Z}^\star
\]

\textbf{Определим операции}:

\fig[0.3]{read-write-out}

Здесь $xi \in \mathbb{Z}^\star$ --- конкатенация слов $x$ и $i$. Создает новый
мир, где входной поток определяется $x$, а выходной прошлым миром. Запись
добавляет $x$ в конец выходного потока. Вывод выводит выходной поток.

\fig[0.7]{stat-semant}

Во время присвоения конфигурация явно представляется в виде пары состояния и
мира $\langle \sigma, \omega \rangle$. В результате переменной $x$ в состоянии
$\sigma$ присваивается результат выполнения выражения, а мир не изменяется.

Операционная семантика языка определяет эталонный интерпретатор. Интерпретатор
--- это программа, которая принимает программу на данном языке и для любого
входа возвращает выход этой программы. Семантика интерпретатора:

\[
    \semant{int} : \Lang \to I \to O
\]
\[
    \semant{int}_\Lang (p, x) = \semant{p}_{\Lother} (x)
\]

Обычно скобки не ставят, чтобы запись не была перегружена разными символами и
читалась легче.

\textbf{Обобщим семантику оператора} и определим $\semant{\bullet}_\Lstat$:

\fig[0.3]{main-stat-semant}

Семантика принимает числа $i$, после чего из когфигурации, где сосояние пусто
(ни одна переменна не определена), выполняется переход по соответствующему
правилу в конфигурацию с каким-то состоянием и миром. Результатом является
выходной поток полученного мира.

Наш компилятор является многопроходным. Сначала получаем программу в виде
синтаксического дерева, затем интерпретируем ее в соответствии с семантикой
большого шага. Далее мы компилируем программу в стековую машину, а из стековой
машины можем выполнить компиляцию в x86.

Фактически стековая машина является языком программирования со своей
семантикой.

Синтаксис стековой машины состоит из двух синтаксических категорий: инструкции
(instructions) и программы (programs)

\fig[0.25]{stack-mach-prog}

Программа стековой машины является списком (возможно пустым) инструкций.

Конфигурация стековой машины включает стек. Множество конфигураций можно
определить следующим образом:
\[
    \Conf_{SM} = \mathbb{Z}^\star \times \Conf
\]

Правила семантики большого шага для СМ:

\fig[0.65]{sm-rules}

$p$ на стрелке означает выполнение оставшейся части программы.

LD кладет значение переменной ($\sigma x$) в стек. ST кладет значение из стека
$z$ в переменную $x$ ($\sigma[x \leftarrow z]$).

Семантика СМ:

\fig[0.35]{sm-semant}

Компилятор из языка операторов в стековую машину:
\[
    \semant{\bullet}^{comp} : \Lstat \mapsto \Lprog
\]

Компилятор --- это функция, которая отображает программу на одном языке в
программу на другом, сохраняя при этом семантику.

Компилятор можно рассматривать как семантику языка программирования. У
компилятора в качетсве семантического домена выступает другой язык. Таким
образом, у языка может быть больше одной семантики.

Опишим семантику в виде. Просто потому что так проще. Пусть исходный язык
состоит из двух синтаксических категорий: выражения и операторы. Компилятор
будет состоять из двух функций, которые генерируют код для каждой категории.
Компилятор выражений (получает выражение, возвращает последовательность
инструкций):

\fig[0.4]{expr-comp-semant}

Пример компиляции:

\fig[0.25]{comp-examp1}

Компилятор операторов:

\fig[0.4]{stat-comp-semant}
\[
    \semant{skip}^{comp} = \epsilon
\]

В случае с присвоением мы при помощи компилятора для выражений получаем
значение, затем кладем его в переменную.

Ветка с домашкой начинается на \testtt{A01}. Если в корне проекта выполнить
\texttt{make}, то начнут выполнять регрессионне тесты. Чтобы их пройти нужно  

\begin{tbl}{p{2.5cm}p{8cm}}
    \texttt{src/World.lama} & Реализация семантики мира \\
    \texttt{src/State.lama} & Реализация состояния \\
    \texttt{src/Expr.lama}, \texttt{src/Stmt.lama}, \texttt{src/SM.lama} &
    Реализация правил и компиляции. Нужно дописать функции, которые возвращают
    failure
\end{tbl}

В компиляторе лучше использовать буфер для списка инструкций

Делать пул реквест в тот же бранч. Сначала убедиться, что тесты работают
локально.
Если его отклонили, то все ок. В табличке результаты. Одна ветка --- одно ДЗ.
В комментарии к пул реквесту указать кто я.

Установка:

\begin{itemize}
    \item Ubuntu 18 с 4 ГиБ памяти,
    \item пакетный менеджер OPAM,
    \item язык программирования OCaml 4.10.1.
\end{itemize}

\begin{Verbatim}
$ vagrant init ubuntu/bionic64
$ vagrant up
$ vagrant ssh
\end{Verbatim}

\begin{Verbatim}
# apt-get update
# apt-get -y upgrade
# apt-get -y install gcc-multilib make m4 unzip bubblewrap gdb
\end{Verbatim}

\begin{Verbatim}
# sh <(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/insta
    ll.sh)
$ opam init -y
$ eval $(opam env)
$ opam switch create lama ocaml-variants.4.10.1+fp+flambda -y
$ eval $(opam env)
$ opam pin add Lama https://github.com/JetBrains-Research/Lama-devel.git\#1.10+
    ocaml4.10 --no-action -y
$ opam depext Lama -y
$ opam install Lama -y
\end{Verbatim}

\section{Вторая домашка}

\end{document}
