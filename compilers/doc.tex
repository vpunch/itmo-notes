% This work is licensed under the Creative Commons Attribution-NonCommercial
% 4.0 International License. To view a copy of this license, visit
% http://creativecommons.org/licenses/by-nc/4.0/ or send a letter to Creative
% Commons, PO Box 1866, Mountain View, CA 94042, USA.

\input{../minpream}

\usepackage{fancyvrb}
\usepackage{fvextra}

% Правильное начертание красивых символов
\usepackage[scr=rsfs]{mathalpha}

% Языки
\newcommand{\Lang}{\mathscr{L}}
\newcommand{\Lother}{\mathscr{M}} % другой
\newcommand{\Lexpr}{\mathscr{E}}  % выражений
\newcommand{\Lstat}{\mathscr{S}}  % операторов
\newcommand{\Linst}{\mathscr{I}}  % инструкций
\newcommand{\Lprog}{\mathscr{P}}  % программ

% Другие красивые обозначения
\newcommand{\Conf}{\mathscr{C}} % конфигурация
\newcommand{\Word}{\mathscr{W}} % мир
\newcommand{\Var}{\mathscr{X}}  % переменная

% Семантическое правило
\newcommand{\neatarrow}{\DOTSB\Rightarrow}

% Семантика
\newcommand{\semant}[1]{\llbracket #1 \rrbracket}

% Ключевые слова языка
\newcommand{\kIf}{\mathop{\mathbf{if}}}
\newcommand{\kFi}{\mathop{\mathbf{fi}}}
\newcommand{\kThen}{\mathop{\mathbf{then}}}
\newcommand{\kElse}{\mathop{\mathbf{else}}}
\newcommand{\kWhile}{\mathop{\mathbf{while}}}
\newcommand{\kDo}{\mathop{\mathbf{do}}}
\newcommand{\kOd}{\mathop{\mathbf{od}}}
\newcommand{\eof}{\mathrm{eof}}

% Инструкции
\newcommand{\CJMPzp}{\mathord{\mathbf{CJMP}}^+_z}
\newcommand{\CJMPnp}{\mathord{\mathbf{CJMP}}^+_{nz}}
\newcommand{\CJMPzn}{\mathord{\mathbf{CJMP}}^-_z}
\newcommand{\CJMPnn}{\mathord{\mathbf{CJMP}}^-_{nz}}
\newcommand{\JMP}{\mathord{\mathbf{JMP}}}
\newcommand{\LABEL}{\mathord{\mathbf{LABEL}}}

\begin{document}

\section{Первая домашка}

\textbf{Язык программирования} (ЯП) --- множество программ на этом языке. ЯП
--- частный случай всех языков. Любой язык состоит из синтаксиста (правила
построения предложений), сементики (смысл предложений) и прагматики
(взаимодействие с носителем).

В языках программирования разделяют \textbf{абстактный и конкретный синтаксис}.

\textbf{Абстрактный синтаксис языка выражений}:

\fig[0.6]{lexpr-synt}

Задано множество переменных, множество бинарных операций и множество
\textbf{абстрактных синтаксических деревьев} (АСД).

АСД является:

\begin{itemize}
    \item изолированным узлом, который помечен переменной или числом;

    \item узлом бинарной операции с двумя дочерними деревьями.
\end{itemize}

Следовательно, дерево упорядочено и определяется по индукции (базой является
первый случай).

\fig[0.3]{lexpr-ast}

Множество АСД определяет язык, а каждая программа определяется АСД. Пример АСД:

\fig[0.25]{lexpr-ast-examp1}

Пример конкретного синтаксиса: \texttt{(a + b) * c}. Чтобы абстрактный
синтаксис выразить в конкретный потребуются дополнительные понятния (в данном
случае старшинство операций).

\textbf{Семантика} --- это всюду определенное отображение языка в семантический
домен:
\[
    \semant{\bullet}_\Lang : \Lang \mapsto \mathscr{D}
\]

Функциональный семантический домен --- множество функций.

Введем \textbf{функцию состояния} $\sigma : \Var \to \mathbb{Z}$, которая
связывает переменные с их значениями.

Рассмотрим \textbf{операционную семантику большого шага}. Она определяется тернарным
отношением:
\[
    \neatarrow_\Lexpr\; \subseteq \Sigma \times \Lexpr \times \mathbb{Z}.
\]

Запись $\sigma \overset{e}{\neatarrow}_\Lexpr n$ означает, что вычисление
выражения $e$ в состоянии $\sigma$ дает значение $n$.

Три семантических правила:

\fig[0.5]{big-step-rules}

В случае с переменной мы должны извлечь из переменной число, чтобы получить
результат.

Линия отделят \textbf{посылку} (правило свеху) от \textbf{заключения} (правило снизу). К заключению можно
приступать только если выполнена посылка. Если у правила отсутствует посылка,
то оно является \textbf{аксиомой}. 

\textbf{Базовые операции}:

\fig[0.25]{lama-ops}

Пример программы: $1 \land (1 / 0)$. Пример описания:

\fig[0.4]{big-step-example1}

Результатом будет неопределенность, так как результат деления на ноль не
определен.

Мы рассмотрели \textbf{строгую (strict) семантику}. Функция называется
неопределенной, если функция от неопределенности есть неопределенность.

Добавим уточнение, что бинарная операция $ \neq \land \mid \lor$ и
добавим два новых правила, которые сделают семантику нестрогой по второму аргументу:

\fig[0.7]{non-strict-rule}

Если левый аргумент --- единица, то результат будет единицей. Если левый
аргумент не равен единице, а правй аргемент --- целое число, то результат
вычисляется из этих двух чисел.

\textbf{Обобщение правил} $\neatarrow_\Lexpr$ в семантику
$\semant{\bullet}_\Lexpr$:

\fig[0.15]{main-expr-semant}

Язык состоит из множества синтаксических категорий.
Существует несколько синтаксических категорий. Категорию выражений (expression) мы
рассмотрели. Следующая категория --- операторов (statement). Рассмотрим язык
операторов:

\fig[0.25]{statements}

Второе правило определяет операцию присвоения, где слева находится переменная,
справа --- выражение (рассмотрено ранее).

\fig[0.2]{assign-synt}

Последнее правило определяет композицию операторов.

Определим семантику этого языка. Пусть наш язык описывает программы, которые
принимают строки целых чисел и возвращают строки целых чисел:
\[
    \semant{\bullet} : \Lstat \mapsto \mathbb{Z}^\star \to
    \mathbb{Z}^\star
\]

Семантика большого шага связывает две конфигурации и программу:
\[
    \neatarrow_\Lstat\; \subseteq \mathscr{C} \times \Lstat \times
    \mathscr{C}.
\]

Значит, что при запуске программы в одной конфигурации, через несколько
шагов получаем другую конфигурацию. Семантика большого шага так называется, так
как при переходе выполняется цепочка шагов.

\textbf{Конфигурация} --- это пара состояния и мира:
\[
    \mathscr{C} : \Sigma \times \mathscr{W}
\]

\textbf{Мир} --- это инкапсуляция входного и выходного потока:
\[
    \mathscr{W} : \mathbb{Z}^\star \times \mathbb{Z}^\star
\]

\textbf{Определим операции}:

\fig[0.3]{read-write-out}

Здесь $xi \in \mathbb{Z}^\star$ --- конкатенация слов $x$ и $i$. Создает новый
мир, где входной поток определяется $x$, а выходной прошлым миром. Запись
добавляет $x$ в конец выходного потока. Вывод выводит выходной поток.

\fig[0.7]{stat-semant}

Во время присвоения конфигурация явно представляется в виде пары состояния и
мира $\langle \sigma, \omega \rangle$. В результате переменной $x$ в состоянии
$\sigma$ присваивается результат выполнения выражения, а мир не изменяется.

Операционная семантика языка определяет эталонный интерпретатор. Интерпретатор
--- это программа, которая принимает программу на данном языке и для любого
входа возвращает выход этой программы. Семантика интерпретатора:

\[
    \semant{int} : \Lang \to I \to O
\]
\[
    \semant{int}_\Lang (p, x) = \semant{p}_{\Lother} (x)
\]

Обычно скобки не ставят, чтобы запись не была перегружена разными символами и
читалась легче.

\textbf{Обобщим семантику оператора} и определим $\semant{\bullet}_\Lstat$:

\fig[0.3]{main-stat-semant}

Семантика принимает числа $i$, после чего из когфигурации, где сосояние пусто
(ни одна переменна не определена), выполняется переход по соответствующему
правилу в конфигурацию с каким-то состоянием и миром. Результатом является
выходной поток полученного мира.

Наш компилятор является многопроходным. Сначала получаем программу в виде
синтаксического дерева, затем интерпретируем ее в соответствии с семантикой
большого шага. Далее мы компилируем программу в стековую машину, а из стековой
машины можем выполнить компиляцию в x86.

Фактически стековая машина является языком программирования со своей
семантикой.

Синтаксис стековой машины состоит из двух синтаксических категорий: инструкции
(instructions) и программы (programs)

\fig[0.25]{stack-mach-prog}

Программа стековой машины является списком (возможно пустым) инструкций.

Конфигурация стековой машины включает стек. Множество конфигураций можно
определить следующим образом:
\[
    \Conf_{SM} = \mathbb{Z}^\star \times \Conf
\]

Правила семантики большого шага для СМ:

\fig[0.65]{sm-rules}

$p$ на стрелке означает выполнение оставшейся части программы.

LD кладет значение переменной ($\sigma x$) в стек. ST кладет значение из стека
$z$ в переменную $x$ ($\sigma[x \leftarrow z]$).

Семантика СМ:

\fig[0.35]{sm-semant}

Компилятор из языка операторов в стековую машину:
\[
    \semant{\bullet}^{comp} : \Lstat \mapsto \Lprog
\]

Компилятор --- это функция, которая отображает программу на одном языке в
программу на другом, сохраняя при этом семантику.

Компилятор можно рассматривать как семантику языка программирования. У
компилятора в качетсве семантического домена выступает другой язык. Таким
образом, у языка может быть больше одной семантики.

Опишим семантику в виде. Просто потому что так проще. Пусть исходный язык
состоит из двух синтаксических категорий: выражения и операторы. Компилятор
будет состоять из двух функций, которые генерируют код для каждой категории.
Компилятор выражений (получает выражение, возвращает последовательность
инструкций):

\fig[0.4]{expr-comp-semant}

Пример компиляции:

\fig[0.25]{comp-examp1}

Компилятор операторов:

\fig[0.4]{stat-comp-semant}
\[
    \semant{skip}^{comp} = \epsilon
\]

В случае с присвоением мы при помощи компилятора для выражений получаем
значение, затем кладем его в переменную.

Ветка с домашкой начинается на \testtt{A01}. Если в корне проекта выполнить
\texttt{make}, то начнут выполнять регрессионне тесты. Чтобы их пройти нужно  

\begin{tbl}{p{2.5cm}p{8cm}}
    \texttt{src/World.lama} & Реализация семантики мира \\
    \texttt{src/State.lama} & Реализация состояния \\
    \texttt{src/Expr.lama}, \texttt{src/Stmt.lama}, \texttt{src/SM.lama} &
    Реализация правил и компиляции. Нужно дописать функции, которые возвращают
    failure
\end{tbl}

В компиляторе лучше использовать буфер для списка инструкций

Делать пул реквест в тот же бранч. Сначала убедиться, что тесты работают
локально.
Если его отклонили, то все ок. В табличке результаты. Одна ветка --- одно ДЗ.
В комментарии к пул реквесту указать кто я.

Установка компилятора языка Lama:

\begin{itemize}
    \item Ubuntu 18 с 4 ГиБ памяти,
    \item пакетный менеджер OPAM,
    \item язык программирования OCaml 4.10.1.
\end{itemize}

\begin{Verbatim}
$ vagrant init ubuntu/bionic64
$ vagrant up
$ vagrant ssh
\end{Verbatim}

\begin{Verbatim}
# apt-get update
# apt-get -y upgrade
# apt-get -y install gcc-multilib make m4 unzip bubblewrap gdb
\end{Verbatim}

\begin{Verbatim}
# sh <(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/insta
    ll.sh)
$ opam init -y
$ eval $(opam env)
$ opam switch create lama ocaml-variants.4.10.1+fp+flambda -y
$ eval $(opam env)
$ opam pin add Lama https://github.com/JetBrains-Research/Lama-devel.git\#1.10+
    ocaml4.10 --no-action -y
$ opam depext Lama -y
$ opam install Lama -y
\end{Verbatim}

regression 

\section{Вторая домашка}

Задача: реализовать компилятор СМ в GAS x86.

Ветка для решения: \texttt{A02-straight-line-x86}. Нужно использовать код из
предыдущей домашки. 

\begin{Verbatim}
git remote rename origin fork
git remote add original https://github.com/danyaberezun/compilers-2021-spring
git fetch original
git checkout -b A02-straight-line-x86 original/A02-straight-line-x86
\end{Verbatim}

\begin{tbl}{p{2.5cm}p{8cm}}
    \texttt{Mov (opnd, opnd} & Копирует значение из первого во второй операнд \\
    \texttt{Binop} & делает бинарную операцию\\
    \texttt{IDiv} & Деление целого \\
    \texttt{Cltd} & s
\end{tbl}

Разницы между X86 и стековой машиной практически нет. У обоих есть стек, мир и
состояние. Здесь входным потоком будет stdin, выходным --- stdout. Память будет
состоянием.

Регистров в стековой машине нет. Но их нужно использовать при генерации кода. 
Будем использовать символическую интерпретацию. Будем генерировать код с
помощью символического интепретатора для стековой машины. На стеке будут лежать
не данные, а размещения (регистр, позиция на стеке, либо переменная в памяти).

Раньше компилятор получал конфигурацию и код. Сейчас компилятор будет получать
окружение и код. Окружение можно считать объектом. 

Размещения:

\begin{tbl}{p{2.5cm}p{8cm}}
    \texttt{R (id)} & регистр \\
    \texttt{S (int)} & позиция на стеке \\
    \texttt{M (string)} & именованная локация в памяти \\
    \texttt{L (int)} & k
\end{tbl}

Регистры:

\begin{tbl}{p{2.5cm}p{8cm}}
    \texttt{ebx} & регистр (ebx, ecx, esl,  \\
    \texttt{ecx} & делает бинарную операцию\\
    \texttt{esl} & Деление целого \\
    \texttt{edl} & k \\
    \texttt{eax} & Деление \\
    \texttt{edx} & Деление\\
    \texttt{ebp} & \\
    \texttt{esp} & 
\end{tbl}

READ -- отводим новую позицию на символическом стеке (сначала выделяются
регистры, затем стек). Получаем новую позицию и новое окружение. Возвращается
пара --- новое окружение и сгенерированный код

env.allocate -- выделить новую позицию на стеке.

ST (x) снять с символического стека, засунуть в переменную

Важно создавать переменную во время чтения, если она не определена. 

\section{Третья домашка}

Частично корректные компиляторы расширяют область определения программ. Они не
строго соответсвуют семантике. Ее поведение может оличаться после компиляции.
Эталонный интерпретатор полностью повторяет операционную семантику.

Компиляторы как правило является частично корректными. Просто потому что это
сложно. Частичная коррекция достигается не специально.

Результат какой-то программы определяется ее семантикой или эталонным
интерпретатором.

\textbf{Тьюринг полнота} --- это возможность реализовать любую вычислимую функцию.

\textbf{Вычислимая функция}:
\[
    f: \mathbb{N}^k \to \mathbb{N}
\]

На данный момент наш язык позволяет реализовать только полиномы, он не является
тьюринг-полным.

Тут написать про оптимальность компилятора, перерисовать. Минимум шагов.

Задача оптимальной компиляции даже нашего языка неразрешимая. 

10-я проблема Гильберта. Пусть есть многочлен с n переменными и целыми
коэффициентами $p(x_1, x_2, \cdots, x_k)$. Корни ищатся перебором. Если к нулю
не сходится, то будет выполняться бесконечно. Процедуры, которая позволит найти
корни без перебора не существует.

Синтаксический анализ занимает меньшаю часть компилятора (четверь или десятую).

Синтаксически центричный принцип создания компилятора. Конкретный синтаксис языка
программирования задается КС грамматикой. Конкретных синтаксисов у одного языка
может быть несколько (например поддержка ключевых слов на русском языке).

Синтаксический анализатор преобразует конкретный синтаксис в абстрактный.

Сейчас у нас есть абстрактный синтаксис, но нет конкретного.

Дерево вывода КС грамматики является деревом абстрактного синтаксиса.

Проблемы:

На самом деле больниство языков (даже простых) синтаксис не является КС.
Пример для языка C (конструкция \texttt{a * b}):
\begin{verbatim}
typedef int a;

a * b;

int f (int a, int b) {
    return a * b;
}
\end{verbatim}

Во-вторых, дерево вывода не является АСД, так как один язык может иметь
несколько грамматик, а АСД одно.

В-третьих, грамматика может быть контекстно зависима. Например,
\begin{verbatim}
<A <B>> f () {}

a >> b
\end{verbatim}
Терминал \texttt{>>} означает разное в зависимости от своей синтаксической
позиции.

Отступы не значащие, но не строго. Напримерм, в си нельзя удалить пробелы
здесь (это еще одно подстверждение, что грамматика не КС):
\begin{verbatim}
void f () { ... }
\end{verbatim}

В реальности используются монадические парсер-комбинаторы.

Атрибутные грамматики --- это КС грамматика, где для каждого нетерминала
указано 2 множества атрибутов. Атрибуты бывают наследуемые и синтезируемые.
Если воспринимать нетерминал как процедуру, которая распознает что-то во
входном потоке. Наследуемые атрибуты --- это фаормальные параметры распознающей
процедуры, а синтезируемые атрибуты --- это результат.

То есть раньше КС-грамматика распознавала строку и возвращала 0 или 1
(результат распознавания), а сейчас грамматика параметризована и может
возвращать больше результатов.

L-атрибутные грамматики.

L -> R1 R2 ... R3 

Схема L-атрибутного анализа:
\begin{verbatim}
L[a] -> x=R1[a] y=R2[x] z=R3[y] {z}
\end{verbatim}

Наледуемый атрибут можно использовать везе. Терминалы могут использовать
синтезируемые атрибуты предыдущих терминалов. Результатом является z

Атрибуты позволяют выразить контестную зависимость.

Будем использовать левоатрибутный анализ.

Как реализовывать такие грамматики?

Есть монадические парсер-комбинаторы. Комбинатор --- это функция высшего
порядка, она комбинирует функции. Парсер принимает входной поток и что-то
простое распознает в нем.

Фукнция высшего порядка --- это функция, принимающая в качетсве аргументов
другие функции или возвращающая другую функцию в качетсве результата.

\begin{verbatim}
fun (stream) -> Ok (result, stream) | fail (desc)
\end{verbatim}

Получает список, возвращает результат и остаток списка.

Парсер комбинатор принимает что-то и возвращает парсер
token принимает t и возвращает функцию, которая распознает это t.

atl --- парсер альтернативы. Является левопредпочтительным, так как возвращает
результат левого парсера, если распознавание с его помощью удалось. Иначе
применяется правый парсер.

Монадические комбинаторы: seq.

Данный комбинатор комбинирует парсер и функцию, которая получает результат
предыдущего парсера и возвращает парсер.

Ostap улучшенная реализация.

Лама содержит в себе DSL (предмето ориентированный язык) для описания
синтаксического анализатора.

Начинается символом syntax. Является расширенной формулой бэкуса наура.

Lexer.lama --- лексический анализатор. Набор примитивных парсеров. Содержит
регулярки для терминалов (число, отступ)

Нужно дописать Parser.lama

memo --- мемоизатор. eta --- расширение, которое делает функцию из того, что
следует далее.

Driver.lama --- драйвер. Компонент компилятора, с которого начинается его
работа. Разбирает опции командной строки, что-то запускает...



Пример простого парсера:
\begin{verbatim}
fun eof (stream) {
  case stream of
    {} -> Ok ({}, stream)
  | _  -> Fail ("EOF expected")
  esac
}
\end{verbatim}

Комбинатор --- это функция, которая получает действие и возвращает измененное
действие.

Пример парсер-комбинатора, распознающего символ:
\begin{verbatim}
fun token (t) {
  fun (stream) {
    case stream of
      t0 : stream0 -> if compare (t0, t) == 0
                      then Ok (t, stream0)
                      else Fail (t.string ++ " expected")
                      fi
    | _            -> Fail (t.string ++ " expected")  поток пустой
    esac
  }
}
\end{verbatim}

В данном случае действием является распознающая символ функция, которая
определяется самим комбинатором и изменяется так, чтобы распознавать
определенный символ.

Пример монадического парсер-комбинатора:
\begin{verbatim}
fun seq (p, q) {    p - парсер, q - комбинатор
  fun (stream) {
    case p (stream) of
      failure@Fail (_)     -> failure
    | Ok (result, stream0) -> q (result) (stream0)
    esac
  }
}
\end{verbatim}

Монада определяет следующее вычисление на основе результата предыдущего.

Монадический парсер-комбинатор реализует схему L-атрибутной грамматики.

В модуле Ostap улучшенная реализация парсеров.

Семантические терминалы называются semantic action

\section{Четвертая домашка}

Написать оптимальный компилятор невозможно

Расширим язык операторов структурным потоком управления (structural control
flow).

Называется структурным, так как нет перехода по метке (оператор goto).

\fig[0.6]{stat-scf}

Добавляем два оператора. Они записаны в абстрактном синтаксисе, но в символьной
форме. В виде дерева их можно записать так:


В конкретном синтаксисе обязательно присутсвуют закрывающие конструкции (fi,
od).

Операционная семантика для новых конструкций состоит из 4 правил:

\fig[0.6]{stat-scf-sem}

Семантика есть описание поведения программы.

Добавим синтаксическое расширение. Или синтаксичекий сахар. Это расширение
которое существует в конкретном синтаксисе, но не в абстрактном, в абстрактный
они проецируются.

\begin{verbatim}
    if e1 then s1  ->  if e1 then s1
  elif e2 then s2      else if e2 then s2
  else s3                   else sk
  fi                        fi
                       fi
\end{verbatim}

Достаточно добавить изменения в синтаксический анализатор (парсер), чтобы все
заработало.

\begin{verbatim}
for s1, e, s2 do s3 od -> s1;
                          while e do
                           s3; s2
                          od
\end{verbatim}

Цикл с постусловием:

\begin{verbatim}
do s while e od   ->   s;
                       while e do
                         s
                       od
\end{verbatim}

Реализовывать его при помощи синтаксического расширения ужасно, так как
получаем экспоненциальную сложность в преобразовании

\begin{verbatim}
    do                do
      do              while od
      while od   ->   while do      -> ...
    while od            do
                        while od
                      od
\end{verbatim}

Если при синтаксическом расширении получается нелинейное преобразование, то
лучше его не реализовывать. Поэтому будем добавлять эту конструкцию на уровне
абстрактного синтаксиса. Дз определить семантику.

\section{Пятая домашка}

Задача: расширить компиляцию в стековую машину и X86.

На данный момент язык стековой машины не достаточно выразителен, чтобы
отобразить циклы. Поэтому расширим ее, то есть добавим новые конструкции и
опишим семантику для них.
множество меток:

\[
    \Lang = \{l_1, l_2, \cdots\}
\]


\fig[0.6]{stack-cf}

JMP --- инструкция безусловного перехода к метке, CJMP --- инструкция перехода по 0 или
1 (значение берется из стека).

В описании семантики будем использовать окружение (environment) $\Gamma$. В
нашем случае окружением является программа $P$ (последоваательность инструкций)
, которую мы интерпретируем.  $P [l]$ --- подпрограмма $P$
которая начинается с метки $l$. В последовательсноти инструкций \testtt{...,
LABEL l ...} правая часть и есть $P[l]$.

В семантических правилах будем исходную программу обозначать $P$, а $p$ ---
хвост, до которого мы добрались.д


\fig[0.6]{stack-sem-env}

\fig[0.6]{stack-sem-env-rules}

Метка ничего не делает, из прошлой конфигурации выполняем хвост. Безусловный
переход изменяет только поток управления.

\semant{c} --- код SM для c. Если это выражение, то в итоге появится одно новое
значение на вершине стека. CJMP_z l_s2

\begin{equation}
    \begin{aligned}[c]
        & \kIf c \\
        & \kThen s_1 \\
        & \kElse s_2 \\
        & \kFi
    \end{aligned} \quad \to \quad
    \begin{aligned}[c]
        & \semant{c}\ \text{--- код SM для $c$} \\
        & \CJMPzp\ l_{s_2} \\
        & \semant{s_1} \\
        & \JMP\ l_{\eof} \\
        & \LABEL\ l_{s_2} \\
        & \semant{s_2} \\
        & \LABEL\ l_{\eof}
    \end{aligned}
\end{equation}

Проблема в такой генерации возникает, когда встречается множество вложенных
условий. Тогда переход для выхода будет совершаться многократно (линейно).

Процессоры общего назначения (ARM, X86) устроены так, что используют
предскозание переходов. Условые переходы выполняются заранее, поэтому имеют
нулевую вычислительную стоимость (процессор заранее берет инструкции для
выполненеия из нужного места). Для условных переходов выполняется угадывание,
которое почти всегда верно, но стоимость ошибки выше, чем переход.

\begin{equation}
    \begin{aligned}[c]
        & \kWhile c \\
        & \kDo s \\
        & \kOd
    \end{aligned} \quad \to \quad
    \begin{aligned}[c]
        & \LABEL\ l_c \\
        & \semant{c} \\
        & \CJMPzp\ l_{\eof} \\
        & \semant{s} \\
        & \JMP\ l_c \\
        & \LABEL\ l_{\eof} \\
    \end{aligned} \qquad
    \begin{aligned}[c]
        & \JMP\ l_c \\
        & \LABEL\ l_s \\
        & \semant{s} \\
        & \LABEL\ l_c \\
        & \semant{c} \\
        & \CJMPnp\ l_s
    \end{aligned}
\end{equation}

Вторая генерация более правильная, так как в теле циклав выполняется только
одна команда перехода, хотя такая разница незначительная для современных
процессоров.

Хвост программы по метке сохраняется в окружении.

Метка переходит в метку. бЕзусловный переход тв безусловный. Условный переход
испльзует СМ использует стек, в x86 нужно смотреть в символический стек.
Значение с символического стека нужно переместить в регистр флагов, так как
инструкция условного перехода использует их (cmp сравнивать с нулем).

Рассинхронизация символического стека не происходит, так как в момент перехода
имеем пустой стек.

Интерпретатор выполняет семантику, компилятор генерирует код.

https://docs.oracle.com/cd/E19455-01/806-3773/index.html
https://stackoverflow.com/questions/14267081/difference-between-je-jne-and-jz-jnz

\end{document}
