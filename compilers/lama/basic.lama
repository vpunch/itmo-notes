-- Заметри для Lama 1.10

import List;  -- подключить модуль (unit) для работы со списками
import Fun;   -- функциональные дополнения

-- Язык чувствителен к регистру. Переменные должны начинаться с маленькой
-- буквы. Модули и структуры - с большой.

-- Разделитель операторов ; не ставится после последнего оператора

-- Примитивы:
var d = 10,       -- доступны только целые числа
    s = "hello",  -- строка является массивом однобайтных символов
    c = 'w',      -- символ неявно приводится к своему ASCII-коду
    b = true;     -- булевые значения являются 0 и 1

-- Присвоение является отдельным инфиксным оператором, который возвращает
-- присвоенное переменной значение. Имеет правую ассоциативность.
d := s := 2;

(* Функции являются функциями первого класса (first class). Функции первого
 * класса - это функции, которые являются объектами первого класса. Объект
 * первого класса - это объект, который может быть присвоен переменной, может
 * быть передан функции или возвращен из нее, может быть создан во время
 * выполнения программы (динамически). Объект второго класса - это объект,
 * который не является объектом первого класса.
 *
 * Можно создавать функции высшего порядка, т.е. функции, которые принимают
 * функцию первого класса, либо возвращают ее.
 *)

-- Результат фукнции определяется последним выражением
-- Разделитель после определения функции не ставится
fun id (x) {x}
-- Имеются анонимные фукнции
-- Разделитель здесь нужен, так как определяется переменная функционального
-- типа
var id = fun (x) {x};

-- Контекст (scope expression) создается парой круглых скобок. Как и другие
-- выражения имеет результат выполнения.
(var a; skip);
-- Если возвращать нечего, то используется специальное выражение skip

-- Есть перекрытие имен, одинаковые имена в одном контексте запрещены

-- Структуры данных:
var myarray = [fun () {skip}, "foo"]; -- массив, неизменяемый (элементы
                                      -- изменяемые)
var mylist = {};                      -- пустой список, неявно приводится к 0
var man = Man ("Jonh", "Smith");      -- S-выражение, тег и список аргументов

-- Условное выражение:
if true then printf ("hello"); skip  -- ветка является контекстом
elif false then printf ("never")
else skip
fi;

-- Для реализации циклов имеются 3 выражения: while, do-while, for. Операторов
-- для инкремента или декремента нет.

var i = 5; while i := i - 1 do
  printf ("%d\n", i)  -- 4321
od;

do
  i := i + 1;
  printf ("%d\n", i)  -- 1234
while i != 4 od;

-- for scope, condition, action do scope od
for var i; i := 1, i <= 3, i := i + 1 do
  -- Приведение индекса к строке и конкатенация со спец. символом. Оператор ++
  -- можно применять только к строкам
  printf (string (i) ++ "\n")  -- 123
od;

-- Dot-нотация:
-- f (e1, ..., ek)
-- e1.f (e2 , ..., ek)


-- case-выражение выполняет ветвление в зависимости от стурктуры выражения.
-- Структура описывается при помощи шаблонов.

printf("%s\n",
  case man of
    -- шаблон -> scope
    Man (name, surn) -> name; skip
  | _                -> 0
  esac.string  -- число неявно к строке не приведется
);

-- Шаблоны:
-- p1:p2 или f:s:t       - список, где первый и второй элемент отделены
-- _                     - любое значение
-- C (p1, ..., pk)       - структура
-- [p1, p2] или {p1, p2} - массив или список, где выделены все элементы
-- x@p                   - переменная, которая соответствует шаблону
-- c                     - константа соответсвует константе
-- #shape                - относится к определенному виду значений

(* Виды значений:
 * box          - ссылка (массив, список)
 * val          - примитивное значение
 * str          - строка
 * S-expression - структура
 * fun          - замыкание (closure)
 *)

-- Шаблоны можно применять для описания параметра функции или результата

-- Добавление первого элемента списка в конец

Возникнет ошибка, если в кейс не найден.

var l = {1, 2, 3};

-- var res1 = case l of f:t -> t +++ {f} esac;
var res1 = case l of f:t -> t:f esac;
-- var res2 = fun (f:t) {t +++ {f}} (l);
var res2 = fun (f:t) {t:f} (l);

printf(res1.string ++ "\n");  -- {2, 3, 1}
printf(res2.string ++ "\n");  -- {2, 3, 1}

-- Лямбда функция - анонимная функция
-- Связанные переменные (bound variables) - переменные, которые связаны с
-- аргументами функции. Определяются списком параметров.
-- Свободные переменные (free variables) делают функцию зависимой от контекста,
-- в котором она вызывается. Это переменные, которые используются внутри
-- фнукции, но определяются снаружи. Значение определяется динамически в
-- обратном направлении стека вызова функций.

-- Комбинатор - это функция без свободных переменных

-- Рекурсивный факториал
var fact = fun (n) {if n == 0 then 1 else fact (n - 1) * n fi};

var gen = fun (step) {
  fun (n) {if n == 0 then 1 else step (n - 1) * n fi}
};

-- fun y (f) {f (y (f))}
-- Ленивость позволяет использовать в качестве аргументов не значения
-- выражений, а сами выражения. В Ламе нет ленивости по умолчанию, как в
-- Хаскеле, поэтому обернем внутренний вызов функцией, чтобы избежать
-- бесконечных вызовов.
fun lazy_y (f) {
  fun (n) {f (lazy_y (f)) (n)}
}


var res1 = fact (4);

var res2 = gen (gen (gen (gen (gen (fun () {0}))))) (4);

var res3 = lazy_y (gen) (4);

var res4 = fix (gen) (4);  -- бесконечная ленивая композиция из указанной
                           -- функции (комбинатор неподвижной точки)

-- Неподвижные точки функции являются решением уравнения f(x) = x. Если левая
-- часть равна правой, то справедливо равенство f(f(...f(x)...)) = x.
-- Данный комбинатор определяется похоже, поэтому он получил такое название.
-- Ленивость позволяет прервать рекурсию, когда достигается определенное
-- условие.

printf("%d, %d, %d, %d\n", res1, res2, res3, res4);


(* Имеется возможность определять инфиксные операции. Приоритет указывается
 * относительно других операций (at, after, before).
 *
 * Одинаковые операции имеют одинаковый приоритет, поэтому порядок их
 * выполнения определяется ассоциативностью (или явно скобками). При левой
 * ассоциативности (infixl) выполнение слева направо, при правой (infixr) -
 * справа налево. Если ассоциативность не определена, то возникнет ошибка,
 * когда она понадобится.
 *)

-- Пример определения инфиксной операции добавления пары, где не определена
-- ассоциативность и приоритет ниже :
public infix <- before : (st, [x, v]) {
  fun (y) {
    if compare (x, y) == 0 then v else st (y) fi
  }
}

-- Доллар дает вычисляет результат из выражения справа и помещает его в функцию
-- слева, как в Хаскеле. Имеет самый слабый приоритет (после :=).

fun foo (x) {x / 2}

printf ("%d, %d, %d, %d\n",
  foo (10) + 10,      -- foo 10 + 10   -> 15
  foo (10 + 10),      -- foo (10 + 10) -> 10
  foo $ 10 + 10,      -- foo $ 10 + 10 -> 10
  foo $ foo $ 10 * 2  -- 5
)


var bar = foldl (infix #, id,      -- (((id # l1) # l2) # l3) -> id (l1 (l2 (l3)))
  map (fun (i) {fun (x) {x + i}},  -- {x + 1, x + 2, x + 3}
       {1, 2, 3})
); 

printf("%d\n", bar $ 10)
-- (id * l1 * l2 * l3) (10)
-- (l1 * l2 * l3) (10)
-- l1 (l2 (l3 (10)))
-- 10 + 3 + 2 + 1


-- compare (x, y) - вернуть разницу
-- length (x)     - вернуть длину ссылочного значения


printf возвращает 0x0, tl возвращает 0, когда список пуст, пустой список
приводится к false
